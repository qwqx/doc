1. 顺序消息

    - 生产端：单一生产者、串行发送
    - 存储：同一MesaageGroup的消息会存在同一个队列
    - 消费端：框架保证顺序投递、业务要避免异步、批量拉取导致的乱序、注意重试问题。
      队列粒度：一个队列一个消费者天然保证，
      消息粒度：会锁定消息状态保证前一条被消费了才能消费下一条，多个消费者不会并发消费

2. 重复消息

    - 产生原因：

        - 生产者重复发送：生产者可能因为网络问题导致消息重复发送（重试两次）

        - mq Server宕机：offset未持久化、主从同步offset失败

        - 消费者未正确处理：消费者可能因为代码问题或者重平衡、消费者挂了（消费了offset 未提交）导致消息重复消费。

        - 消费者确认机制问题：如果消费者使用了手动确认，可能因为确认失败导致消息重新投递。

    - 解决方法：

                 - 生产者端：
      使用事务消息确保消息只发送一次。
      使用消息唯一标识(message ID)，在发送前检查是否已存在于发送队列中。
      - 消费者端：
      保证消费者ID的唯一性，防止因重平衡导致的消息重复。
      实现消息唯一性校验，比如使用数据库或缓存记录消费的消息ID，确保同一个消息ID只被消费一次。
      使用消息的唯一标识(message ID)进行去重。
      使用消费者的集群模式，通过RocketMQ的负载均衡和故障转移机制来减少重复消息。
      确保消费者的手动确认机制工作正常，确认消息处理成功后再提交确认，避免因为确认失败导致的重投。
      设置合理的消息消费重试策略，比如重试间隔和最大重试次数。
      监控系统，发现重复消息及时处理，并考虑对重复消息的处理策略进行优化。

   **在消费者上线或下线、服务端扩缩容等场景下，都会触发短暂的重新负载均衡动作。此时可能会存在短暂的负载不一致情况，出现少量消息重复的现象。因此，需要在下游消费逻辑中做好消息幂等去重处理。**

​	**同时做到确保一定投递和不重复投递是很难的，RocketMQ择了确保一定投递，保证消息不丢失，但有可能造成消息重复。业务端自己保证**

​	**处理消息重复问题，主要由业务端自己保证：业务幂等和消息去重。**
​	**业务幂等：消费端使用唯一标识来实现，比如数据库表的唯一索引、分布式锁等**
​	**消息去重：消费记录表，相同消息不处理**